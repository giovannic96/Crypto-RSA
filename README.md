# Crypto-RSA
Sistema di autenticazione di messaggi utilizzando la crittografia asimmetrica basata su RSA

# Testo
Si implementi un sistema di autenticazione di messaggi sicuro utilizzando la crittografia asimmetrica basata su RSA. Il sistema deve prevedere la generazione di numeri pseudo-casuali utilizzando l’algoritmo ANSI X9.17.
 
Dopo che due nodi, A e B, hanno generato ognuno la propria coppia di chiavi essi si scambiano, in chiaro, la chiave pubblica. Successivamente, ognuno dei due nodi autentica un messaggio e lo invia all’altro.

# Descrizione del sistema 
Il sistema rappresenta un’applicazione di tipo Client-Server dove i due utenti in questione, A e B, possono effettuare uno scambio di messaggi in maniera sicura utilizzando la crittografia asimmetrica basata su RSA. In primo luogo, viene inizializzato il server in modo che rimanga in ascolto di eventuali client che vogliono connettersi. Dopodiché ai due client viene assegnato un nome (scelto da tastiera) e viene effettuato il collegamento al server tramite la porta 3434, scelta arbitrariamente. Una volta connessi, ad ognuno dei due nodi vengono assegnate le rispettive chiavi pubblica e privata, utilizzando l’algoritmo RSA. A questo punto, prima di iniziare lo scambio di messaggi vero e proprio, è necessario stabilire la sessione tra i due client, che consiste nello scambio, in chiaro, della rispettiva chiave pubblica. Sarà uno dei due utenti ad iniziare la sessione digitando da tastiera la parola “sessione” e inserendo il nome del client con cui si vuole avviare la comunicazione. Fatto ciò, il nodo iniziatore invia la propria chiave pubblica all’altro tramite il server, il quale in questo caso si occuperà soltanto di trasferire in chiaro la chiave al nodo di destinazione. Quest’ultimo, una volta ricevuta, invia a sua volta la propria chiave pubblica al client mittente. A questo punto, la sessione è iniziata e da ora in poi i due client possono scambiarsi i messaggi correttamente. La comunicazione avviene come segue: supponendo che il client A voglia mandare un messaggio al client B, prima di tutto A autentica il messaggio con la propria chiave privata tramite l’algoritmo di Encryption RSA, dopodiché viene mandato al server, il quale si occuperà di trasferire opportunamente il messaggio, crittografato, al rispettivo destinatario. Il client B, ricevendo il messaggio crittografato (autenticato), applica la Decryption RSA utilizzando la chiave pubblica del client A ricevuta precedentemente. In questo modo, si ha la certezza che il messaggio provenga dal client A. Dopo aver letto il testo, B potrà rispondere con un altro messaggio, autenticandolo con la propria chiave privata. Allo stesso modo, il client A effettuerà la decrittografia con la chiave pubblica di B ricevuta in precedenza. I client possono continuamente scambiarsi messaggi finché uno dei due si disconnette scrivendo la parola “logout” oppure se si disconnette il server. 

# Scelte implementative
Il progetto si compone di due packages, uno relativo all’applicazione Client-Server vera e propria (“applicazione”) e uno contenente tutti gli algoritmi utilizzati per la crittografia (“crittografia”). 

*Package crittografia*

In questo package, troviamo le seguenti classi: *RSA*, *ANSI X9.17*, *Miller Rabin*, *TripleDES*, *DES_CBC*, *DES*. 

La classe principale è l’RSA, la quale permette di implementare la tecnica di crittografia asimmetrica richiesta dalle specifiche di progetto. È stata utilizzata, dunque, per due scopi: la generazione delle chiavi e l’autenticazione dei messaggi.

**Generazione delle chiavi**: a tal proposito la classe RSA si è servita di due oggetti appartenenti rispettivamente alle classi ANSI X9.17 e Miller Rabin. Il primo rappresenta il generatore descritto nelle specifiche di progetto ed è stato utilizzato, dunque, per generare i due numeri pseudo-casuali ‘p’ e ‘q’, necessari all’algoritmo per creare le chiavi pubblica e privata. Miller Rabin, invece, è stato utilizzato per effettuare il test di primalità e verificare che i due numeri generati ‘p’ e ‘q’ fossero dei numeri primi, come stabilito dall’algoritmo RSA. Nel dettaglio, l’ANSI X9.17 contiene al suo interno un oggetto appartenente alla classe TripleDES, il quale si serve della classe DES_CBC per implementare il modo di funzionamento Chiper Block Chaining, che utilizza l’oggetto di tipo DES per effettuare la crittografia/decrittografia. Più nello specifico, il TripleDES utilizza due diverse chiavi a 56 bit, scelte arbitrariamente e mantenute segrete, servendosi della prima per effettuare la crittografia e della seconda per effettuare la decrittografia. In output il generatore mostrerà due valori: un numero pseudocasuale a 64 bit (utilizzato dall’RSA come ‘p’ o ‘q’) e un seme a 64 bit che rappresenta il valore del seme all’inizio della successiva generazione. 

**Autenticazione dei messaggi**: a tal proposito è stato implementato un meccanismo che trasforma il messaggio testuale in array di byte, andando a crittografare di volta in volta blocchi di n byte, dove ‘n’ rappresenta il prodotto tra ‘p’ e ‘q’ (si noti che è stata utilizzata la classe BigInteger di Java dal momento che bisognava trattare numeri molto grandi). Pertanto, dopo aver suddiviso il messaggio in blocchi, è stata creata una matrice per differenziare i vari blocchi (ogni riga della matrice rappresenta un blocco) e a questo punto è stata eseguita l’Encryption RSA per ogni riga della matrice. Dopo aver crittografato (autenticato) tutti i blocchi, la matrice è stata convertita in vettore, rappresentante il messaggio che verrà trasmesso al client destinatario. Chiaramente, al momento della suddivisione in blocchi, può capitare che l’ultimo possa rimanere incompleto. Per questo motivo, è stato applicato il padding seguendo lo standard PKCS#5, in base al quale vengono inseriti in coda tanti byte quanti sono necessari a coprire il blocco ed il valore di ognuno di essi è il numero di byte aggiunti. In questo modo, quando viene effettuata la decrittografia, è possibile rimuovere il padding andando a togliere tanti byte quanto è il valore dell’ultimo byte ricevuto.

*Package applicazione*

Questo package contiene le classi necessarie per l’implementazione di un’applicazione di tipo Client-Server. Al suo interno sono presenti le seguenti classi: *Client*, *Server*, *TypeMessage* e *KeyObject*.

La classe Client gestisce le operazioni che può effettuare un utente, ovvero scrittura e lettura di messaggi. Per quanto riguarda la scrittura, è presente un ciclo infinito che attende un input da tastiera da parte dell’utente (ad es. il nome o il messaggio da trasmettere al destinatario). Per quanto riguarda la lettura, invece, si avrà un thread apposito che rimane sempre in ascolto di eventuali messaggi da parte del Server, eseguendo diverse risposte a seconda del tipo di messaggio ricevuto. 

La classe Server gestisce la connessione con i vari client e permette una corretta comunicazione tra essi. Essa possiede una lista per tenere traccia dei client che si connettono, infatti si avrà un identificativo univoco per ogni connessione stabilita. Come nel caso del client, si avrà un thread a disposizione per ogni utente, che si occuperà di leggere i messaggi e adoperare le relative operazioni in base al loro tipo. La classe TypeMessage è presente proprio per questo motivo. Infatti, possono essere inviati i seguenti tipi di messaggi: 
*	INFO: utilizzati dal server per fornire eventuali informazioni di carattere generale ai client (ed es. nuova connessione di un utente, disconnessione di un utente, errori di vario genere, ecc.);
*	LOGOUT: utilizzati dal client per disconnettersi correttamente dall’applicazione;
*	MESSAGE: essi rappresentano i messaggi veri e propri che vengono scambiati tra i due utenti;
*	SESSIONE: stabiliscono la sessione tra i due client (scambio delle chiavi pubbliche).

I messaggi di sessione vengono utilizzati sia dal client (per inviare al server la chiave pubblica) che dal server (per inviare la chiave al corretto destinatario). Infatti, la chiave è stata gestita come un oggetto vero e proprio, da qui l’implementazione della classe KeyObject. Essa ha al suo interno due variabili di tipo BigInteger: una rappresenta il valore di ‘e’ (o ‘d’) e una rappresenta il valore di ‘n’, dal momento che le chiavi in RSA sono costituite dalla coppia {e, n} (chiave pubblica) oppure dalla coppia {d, n} (chiave privata). Naturalmente, la classe KeyObject implementa l’interfaccia Serializable in modo tale da essere passata correttamente attraverso gli stream di comunicazione. 
